>Give a concise overview of your design. How did you divide the code into classes and methods? How does your design for Project 7 differ from the design you inherited for Project 6? How did you respond to feedback?

Our design includes one large package, tunecomposer, which contains all of our program's files. TuneComposer.java initializes the program on the whole, bringing up the stage and setting up other files. The MainController file coordinates the bulk of user interactivity, connecting all the other controllers to form one cohesive program and coordinate user actions and visual display. Interaction with notes has now been moved to the Composition file, which allows their creation. That java file relies on the Constants files, which includes a list of constants, the Instrument file, which describes the information related to each type of instrument, and the NoteRectangle class, which defines the duration, location, and visual of created note rectangles (and allows their editing and movement). The Gesture class allows for the user's creation and deletion of gestures, along with the accompanying border around said gestures. The CompositionState class allows the user a concise way to store the state of the program and notes. The UndoRedoAction class does as its name implies, making Composition States available for undoing and redoing actions. MenuBarController also uses CopePasteActions, a class object that allows the user to copy, cut, and paste using the system clipboard, and copy/paste to/from txt files. Finally, package contains CSS for styling in the user interface, and many FXML files to lay out the user interface and areas for user interaction.

We divided code into classes and methods by looking for simplicity and the Single Responsibility principle, attempting to have each class govern one responsibility and each method "do one thing and do it well."

We focused initially on functionality, and then on elegance. 

To our knowledge, we completed all the program's TODOs and followed feedback to the best of our ability; we focused more on following feedback and TODOs than in previous projects. 

Our design differs in that we moved a lot of methods and fields into classes which better fit their responsibilities (moving note initilization into the NoteRectangle class, moving more methods into the MenuItem class, organizing the CopyPasteAction class by responsibility). We also added a timeline in the MainController to routinely check whether there is something in the clipboard (so that we can properly enable/disable "Paste" menu item).

Our stretch goals included (1) letting the user copy the entire composition rather than just selected notes with the "Copy Composition" menu item (2) letting the user "write"/copy selected notes to a (preexisting) txt file for storage (3) letting the user load/add notes and gestures from a selected txt file (must use correct syntax) (4) Using a slider to let the user choose a default note duration/length. We think that stretch goals 1,2, and 3 enhance the asked-for interfaces/features, and fit in with the general goal of Project 7. Stretch goal (4) was added before we received the Project 6 grade, but we kept it because it extends the function of Project 4 (makes editing notes easier).

>Explain why your way was the elegant way to do it. Address any improvements you made based on my feedback.

We continued in our tradition of splitting fxml and JavaFX classes into different classes and controllers to distribute responsibilities on a smaller scale, and decomposed & refactored methods to meet Single Responsibility Principle on a smaller scale. Since we're still favoring composition over inheritance, we do not violate the Liskov Substitution Principle. Although we do not explicitly use interfaces, I would argue that we keep to the spirit of Interface Segregation by splitting more specific tasks across different files, avoiding a large, general MainController. Additionally, I think that, by keeping things "general" by having more fields in the NoteRectangle class and elsewhere, we shy away from demanding specifics and attempt at following the Dependency Inversion principle. We continued to move towards encapsulation to protect from modification and adhere to the Open/Closed Principle. Keeping the MainController class as the storage of the main arrays (NoteRectangleList and SelectedNotes) allows us to extend the program, and keep access to those important fields centralized and not duplicated. To that effect, we favor a more cohesive program to minimize duplication, to increase simplicity, and to maximize encapsulation. As always, we are refining our documentation and changing our code to make it more self-explanatory, especially with intention-revealing names.

In accordance with suggestions, we've moved initialization of NoteRectangle actions into the NoteRectangle class itself, used more intention-revealing names, reduced the amount of intimacy, and moved objects (ie SelectRectangle) into fxml.

>Explain what, if anything, in your solution is inelegant and why you didn't make it elegant (for example, maybe you didn't >have time or the knowledge to fix it).

Our program does violate the Law of Demeter, in that many controllers go through the main controller to get something done. However, we thought that violating this law actually helped with the simplicity and clarity of our project, and so favored those other principles of elegance over the Law of Demeter (adding many methods and creating a maze of responsibilities would have been less elegant). With time in the future, we may find an even better balance. Although many programs do go through the main controller, we think that this method of a program with more cohesion is simpler, more concise, more readable, and more maintainable. At this point, extensibility isn't as big of a priority, since the scope of this project has become more clear. As always, with more time and knowledge, more refactoring could be done.

>Include an estimate of your velocity. How many story points did you estimate you would complete during this project? How many did you actually complete, how many person-hours did the team spend, and what is the ratio of points/person-hour?

We estimated that we would complete 21 story points, and actually ended up completed about 24 (still working at getting better at estimation). We spent about 29+ hours on this project, so around 10 hours per person, and that means that the rate of points/person-hour was about 0.82758620689.

>Include a short summary of your team retrospective. What went well that your team will keep doing during the next project >assignment? What will you improve? How?

Because of test schedules and other work schedules, we didn't have as much time to work on this project (at least early on). Hopefully next time we'll be able to meet on the earlier side again, since that had worked well earlier. We worked a bit more outside of meetings than usual as well, for the same reason. Our use of GitHub has improved, and hopefully communication will continue to grow in frequency and quality. Next time, we will spend more time in the "planning" phase, and hopefully have a chance to incorporate more principles of elegant design!

Best regards,
Kaylin, Jing, and Tyler

