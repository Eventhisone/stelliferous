> Give a concise overview of your design. How did you divide the code into classes and methods? How does your design for Project 4 differ from the design you inherited for Project 3? How did you respond to feedback?

- As a whole, we break our code into three packages: controller, tunecomposer, and view. The TuneComposer package only contains TuneComposer.java, with the main() method that starts the program and start() that sets the FXML scene and stage. The view package contains our CSS file, which styles all static/possible elements, and two FXML files. TuneComposerNoteSelection.fxml formats the foreground of our program, with a menu, instrument selection, and composition pane for users to place notes. TuneComposerBackground.fxml creates a canvas to serve as the background of the composition window. In the controller package, we keep all files which actively manage events within the composition window. TuneComposerBackground.java controls TuneComposerBackground.fxml, and adds horizontal lines to divide based on pitch. MidiPlayer.java holds the MidiPlayer class, which can used by TuneComposerNoteSelection.java. TuneComposerNoteSelection.java handles all action events (menu, radio buttons, composition pane actions), and constructs a MidiComposition object based on the placement and size of NoteRectangle objects. To provide those NoteRectangle objects, the class in NoteRectangle.java includes a rectangle, its dimensions, coordinates, and corresponding instrument.

- We divided the code into classes and methods based on the principles of Least Astonishment and that of code decomposition. Whenever possible, we broke code off into different classes, and had methods delegate tasks to one another. Our design for Project 4 is much better organized than in Project 3 in that we put code into seperate files based on their function and required accessibility. We responded to feedback with better variable names, a focus on clarity, and generally better organization of code. 

- As part of our "stretch goal," we added additional 'special effect' instruments, added a "clear" menu item to allow the user to clear all notes, and added a "shift" hotkey option (if the user holds down 'shift' while dragging on the composition panel, they will create new notes rather than a selection rectangle).

> Explain why your way was the elegant way to do it. Address any improvements you made based on my feedback.

- Because of how modular our code is, it is more simple, in that the logical relationships between classes and methods can be more clearly understood. It is maintainable, as dividing the code into smaller 'bits' isolates the area where a problem could occur. Dividing code into different files and packages also gives it greater extensibility, as a programmer can now expand different areas of the code into different, unexpected directions. 

> Explain what, if anything, in your solution is inelegant and why you didn't make it elegant (for example, maybe you didn't have time or the knowledge to fix it).

- As usual, there is always more refactoring, reorganization, and research that could be done with greater time. Because we aren't that knowledgable about working in Java, JavaFX, CSS, or FXML, a seasoned programmer might know simpler ways/functions/libraries of accomplishing what we did. We could probably break our fxml code into seperate files as well, but at this point we don't have the technical knowledge to establish complex communication between controllers.

> Finally, describe how your team collaborated on the project. What did you do together? What did you do separately? What did each team member contribute?

- We met together several times, and collaborated in talking over the best way of approaching code. For the most part, however, individuals worked seperately and on their own time. Together, we discussed the overall layout of the code's functionality, and tackled problems that we'd run into individually. Most 'features,' however, were specifically coded for by individuals alone. Kai worked on the functionality of the play button, helped suggest ideas on the drag select, and worked on general edits. Tyler used and refactored his old team's projects, implemented the click/control-click on notes, selection rectangle dragging, added the stretch goal features of "shift" to add notes while dragging & "clear" menu item, and formatted the instruments' colors and MidiEvent Program Changes (+ general refactoring, code organization). Jing focused on the dragging and streching functions of the rectangles and create a new class, NoteRectangle, to implement the new features of the notebar and also contributed a little on how to connect the fxml and .java with css file.

> In your reflection on collaboration, include a reflection on estimation: How did you use your estimates? For which requirement(s) did you make the most inaccurate estimate(s)? Why?

- First of all, we started working early because our estimations indicated that we needed a large amount of time. We probably exceeded that estimate of ~30 hrs. We did not place a big emphasis on our initial estimates, as we felt that our limited experience with estimation and these programming languages made precise estimation difficult. I think we divided each assignment/task by association with other tasks, rather than by difficulty. This makes sense, as many features built upon one another. I think that our most inaccurate estimations concerned making the code more elegant and refactoring it, which we didn't really take into account in our in-class estimations.
