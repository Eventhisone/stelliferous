Dear Professor Davis,

>Give a concise overview of your design. How did you divide the code into classes and methods? How does your design for Project 8 differ from your design to Project 7? How did you respond to feedback? (If I get it to you in time.)

Our design includes one large package, tunecomposer, which contains all of our program's files. TuneComposer.java initializes the program on the whole, bringing up the stage and setting up other files. The MainController file coordinates the bulk of user interactivity, connecting all the other controllers to form one cohesive program, coordinate user actions, and give a visual display. Interaction with notes has now been moved to the CompositionController file, which allows their creation through clicking on a pane. That java file relies on the Constants files, which includes a list of constants, the Instrument file, which describes the information related to each type of instrument, and the NoteRectangle class, which defines the duration, location, and visual of created note rectangles (and allows their editing and movement). The Gesture class allows for the user's creation and deletion of gestures, along with the accompanying border around said gestures. The CompositionState class allows the user a concise way to store the state of the program and notes. The UndoRedoAction class does as its name implies, making Composition States available for undoing and redoing actions. MenuBarController also uses CopePasteActions, a class object that allows the user to copy, cut, and paste using the system clipboard, and copy/paste to/from txt files. MenuBarController uses a SaveActions object, which allows the user to save a Composition to a new file, save it to an existing file, and open a Composition from a txt file. Both CopyPasteActions and SaveActions use a CompositionToFile object, which converts Compositions or selected notes into a String, or 'decodes' a string to convert it into notes and gestures. Finally, package contains CSS for styling in the user interface, and many FXML files to lay out the user interface and areas for user interaction.

We continued to keep the Single Responsibility principle in mind when we formed classes, this time breaking up the CopyPasteActions class into CopyPasteActions and SaveActions. Furthermore, we minimized duplication by creating new 'helper classes' like the CompositionToFile class that can decode and encode Strings. We looked to create cohesive classes, and moved some methods accordingly (for example, making MenuBarController delegate responsibilities to other classes rather than fulfilling them itself).

As usual we began by fulfilling the functionality requirements, then moved towards refactoring. 

To our knowledge, addressed the feedback given in the previous project (although there were no specific TODOs to fulfill). Therefore, we mostly used the principles we've learned in class to improve our project and refactor. 

Our design has improved in that we moved a lot of methods and fields into classes which better fit their responsibilities (moved responsibilities of savedActions and CopyPasteActions from MenuBarController into their respective, more fitting classes). We also split some of CopyPaste into CompositionToFile.java so that the notes-to-string and string-to-notes code could be reused.

We're saving our stretching for Project 9, as I think is appropriate.

>Explain why your way was the elegant way to do it. Address any improvements you made based on my feedback.

We keep splitting JavaFX classes into different classes to better distribute responsibilities on a smaller scale, and decomposed & refactored methods to meet Single Responsibility Principle on a smaller scale. I think that we've improved at writing JavaDocs and internal documentation, supplementing self-explanatory code with explanatory documentation when necessary. By "using" different classes rather than inheriting, we avoid the pitfalls of the Liskov Substitution Principle and end up with a less coupled program than we might with inheritance. We do not use interfaces, and thus cannot really pursue the Interface Segregation Principle. Still, I would hazard the argument (knowingly a stretch) that we keep to the spirit of Interface Segregation by splitting more specific tasks across different files, avoiding a large, general MainController. Whenever possible, we maximize encapsulation to protect from modification and adhere to the Open/Closed Principle. Making the currentState class as the storage of the main arrays (NoteRectangleList and SelectedNotes) allows us to extend the program even further, and keep access to those important fields centralized and not duplicated. To that effect, we favor a more cohesive program to minimize duplication, to increase simplicity, and to maximize encapsulation. 

Although we may not have the time to move to a Model-View-Controller system, we are following in its spirit as much as possible. For example, we are seperating a "model" responibility from a "controller" responisibility by moving NoteRectangleList and SelectedNotes out of MainController (which takes user input in the composition pane) and into CurrentState (to simply store the data itself). When appropriate our code uses patterns (ie the Memento Pattern, the Control Pattern) to make our code simpler and more efficient.

As always, we are refining our documentation and changing our code to make it more self-explanatory, especially with intention-revealing names. We still strive to use intention-revealing method and variable names, make variables constants when possible, and reduce the amount of intimacy.

>Explain what, if anything, in your solution is inelegant and why you didn't make it elegant (for example, maybe you didn't have time or the knowledge to fix it).

Our program still violates the Law of Demeter, since many controllers go through the main controller to get something done. I'd still argue that violating this law actually helped with the simplicity and clarity of our project, and so favored those other principles of elegance over the Law of Demeter (adding many methods and creating a maze of responsibilities would have been less elegant). Although many programs do go through the main controller, we think that this method of a program with more cohesion is simpler, more concise, more readable, and more maintainable. At this point, extensibility isn't as big of a priority, since the scope of this project has become more clear. Still, this increases coupling between classes to an uncomfortable point; although our cohesion within classes has improved, our coupling between them is something to keep working on. 

We had run into some problems with the Memento pattern using too much space, at one time running into "heap is full" messages. However, we were able to solve those issues with refactoring and debugging, and retain our belief that the Memento pattern works best. In addition, we don't use the Composite pattern to group and ungroup notes into gestures. This may decrease the simplicity and elegance of the program in some areas, but I maintain that there's more extensibility in straying from inheritance; the gestures might be less easy to manipulate, but they can be manipulated in more ways this way ('filtering' notes within a gesture, perhaps).

As always, with more time and knowledge, more refactoring could be done.

>Include an estimate of your velocity. How many story points did you estimate you would complete during this project? How many did you actually complete, how many person-hours did the team spend, and what is the ratio of points/person-hour?

We estimated that we would complete 18 story points, and actually ended up completed about 19 (still working at getting better at estimation). We spent about 25.5+ hours on this project, so around 6.375 hours per person, and that means that the rate of points/person-hour was about 0.74509803921. In this project our velocity slowed down, but I think that's because we tried out a variety of different ways of refactoring CopyPasteActions. I think we are getting better at estimating story points and timing, yes... more experience certainly helps.

>Include a short summary of your team retrospective. What went well that your team will keep doing during the next project assignment? What will you improve? How?

This did feel like a shorter assignment, which we appreciated (although unbeknownst to us, we'd completed part of it for our Project 8 stretch goals). Unfortunately, we didn't have a chance to meet until later in the week again, but we used our time productively and communicated well throughout. Everyone participated strongly, and contributed good ideas. We'll continue communicating well and being as proactive as possible. Hopefully we can improve our creative skills and bounce more ideas off one another in Project 9.

Sincerely yours,

Kaylin, Zach, Jing, and Tyler

