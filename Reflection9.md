Dear Professor Davis,

>Give a concise overview of your design. How did you divide the code into classes and methods? How does your design for Project 9 differ from your design to Project 8? How did you respond to feedback? (If I get it to you in time.)
____
For the project 9, we focused on adding features which did not result in big changes of the whole structure for our program. We added one new class to implement the popup menu feature and for other features, we just added new methods and fields because these are just an development for the current performance, which can still be counted as the responsibilities for the existed classes.
And all together, we implemented 6 new features.
a) We have a new class called PopUpMenu, which included two context menus, one for NoteRectangles and one for the CompositionPane so that the users can click on the pane to decide the position they want the noteRectangles to be pasted to. 
b) In the contextmenu for the rectangles, we have also added group, ungroup, copy and cut these menuitems and synchronized them with the menuitems in the menubar so that when the menuitems in the menubar are disabled, so will the ones in the context menu. We created these menuItems as fields rather than just a local variable in order to be able to access it from the menuBarController where all the disable and enable buttons actions are handled.
c) We added the pause, move forward and move backward actions for the TuneComposer so now we can manipulate the redline and start the composition in the middle rather than always have to start it from the beginning. We did so through resetting the translation animation for the redline when the endcomp and the above actions are called, and resetting the start tick and duration of the notes for the midiplayer.
d) We added several boolean values and new functions inside the NoteRectangle class, so now we can allow the user to stretch the noteRectangles from the 5 pixels within the left edge.
e) We added a properties pane on the left side of the pane, just below the duration slider, so when the user is creating a new noteRectangle or selecting a rectangle, the properties including xPosition, yPosition, width, instrument and the number of gestures it is in would be presented in that pane. This allows the user to get more specific knowledge regarding each NoteRectangles.
f) We opened the access of instrument to the user so that they are allowed to change the instrument for the exisited note. The user needs to select the instrument they want to change to first and then through the context menu for the rectangles, clicking the change instrument button and this actions would calls for the program to read from the radiobutton again and change the selected notes to that instrument from the NoteRectangle class.

In the feedback we got from the project 8, there's no comment on the structure of the class and the design flaws we might possess, so we basically refactored the way we saw to be appropriate.

____
Our design includes one large package, tunecomposer, which contains all of our program's files. TuneComposer.java initializes the program on the whole, bringing up the stage and setting up other files. The MainController file coordinates the bulk of user interactivity, connecting all the other controllers to form one cohesive program, coordinate user actions, and give a visual display. Interaction with notes has now been moved to the CompositionController file, which allows their creation through clicking on a pane. That java file relies on the Constants files, which includes a list of constants, the Instrument file, which describes the information related to each type of instrument, and the NoteRectangle class, which defines the duration, location, and visual of created note rectangles (and allows their editing and movement). The Gesture class allows for the user's creation and deletion of gestures, along with the accompanying border around said gestures. The CompositionState class allows the user a concise way to store the state of the program and notes. The UndoRedoAction class does as its name implies, making Composition States available for undoing and redoing actions. MenuBarController also uses CopePasteActions, a class object that allows the user to copy, cut, and paste using the system clipboard, and copy/paste to/from txt files. MenuBarController uses a SaveActions object, which allows the user to save a Composition to a new file, save it to an existing file, and open a Composition from a txt file. Both CopyPasteActions and SaveActions use a CompositionToFile object, which converts Compositions or selected notes into a String, or 'decodes' a string to convert it into notes and gestures. Finally, package contains CSS for styling in the user interface, and many FXML files to lay out the user interface and areas for user interaction.

We continued to keep the Single Responsibility principle in mind when we formed classes, this time breaking up the CopyPasteActions class into CopyPasteActions and SaveActions. Furthermore, we minimized duplication by creating new 'helper classes' like the CompositionToFile class that can decode and encode Strings. We looked to create cohesive classes, and moved some methods accordingly (for example, making MenuBarController delegate responsibilities to other classes rather than fulfilling them itself).

As usual we began by fulfilling the functionality requirements, then moved towards refactoring. 

To our knowledge, addressed the feedback given in the previous project (although there were no specific TODOs to fulfill). We did work on decomposing "scary" methods, as requested in Project 7 rubric feedback. Therefore, we mostly used the principles we've learned in class to improve our project and refactor. 

Our design has improved in that we moved a lot of methods and fields into classes which better fit their responsibilities (moved responsibilities of savedActions and CopyPasteActions from MenuBarController into their respective, more fitting classes). We also split some of CopyPaste into CompositionToFile.java so that the notes-to-string and string-to-notes code could be reused.

We're saving our stretching for Project 9, as I think is appropriate.

>Explain why your way was the elegant way to do it. Address any improvements you made based on my feedback.

We keep splitting JavaFX classes into different classes to better distribute responsibilities on a smaller scale, and decomposed & refactored methods to meet Single Responsibility Principle on a smaller scale. I think that we've improved at writing JavaDocs and internal documentation, supplementing self-explanatory code with explanatory documentation when necessary. By "using" different classes rather than inheriting, we avoid the pitfalls of the Liskov Substitution Principle and end up with a less coupled program than we might with inheritance. We do not use interfaces, and thus cannot really pursue the Interface Segregation Principle. Still, I would hazard the argument (knowingly a stretch) that we keep to the spirit of Interface Segregation by splitting more specific tasks across different files, avoiding a large, general MainController. Whenever possible, we maximize encapsulation to protect from modification and adhere to the Open/Closed Principle. Making the currentState class as the storage of the main arrays (NoteRectangleList and SelectedNotes) allows us to extend the program even further, and keep access to those important fields centralized and not duplicated. To that effect, we favor a more cohesive program to minimize duplication, to increase simplicity, satisfy the Open/Closed principle and to maximize encapsulation.

Although we may not have the time to move to a Model-View-Controller system, we are following in its spirit as much as possible. For example, we are seperating a "model" responibility from a "controller" responisibility by moving NoteRectangleList and SelectedNotes out of MainController (which takes user input in the composition pane) and into CurrentState (to simply store the data itself). When appropriate our code uses patterns (ie the Memento Pattern, the Control Pattern) to make our code simpler and more efficient.

As always, we are refining our documentation and changing our code to make it more self-explanatory, especially with intention-revealing names. We still strive to use intention-revealing method and variable names, make variables constants when possible, and reduce the amount of intimacy.

>Explain what, if anything, in your solution is inelegant and why you didn't make it elegant (for example, maybe you didn't have time or the knowledge to fix it).

Our program still violates the Law of Demeter, since many controllers go through the main controller to get something done. I'd still argue that violating this law actually helped with the simplicity and clarity of our project, and so favored those other principles of elegance over the Law of Demeter (adding many methods and creating a maze of responsibilities would have been less elegant). Although many programs do go through the main controller, we think that this method of a program with more cohesion is simpler, more concise, more readable, and more maintainable. At this point, extensibility isn't as big of a priority, since the scope of this project has become more clear. Still, this increases coupling between classes to an uncomfortable point; although our cohesion within classes has improved, our coupling between them is something to keep working on. 

We had run into some problems with the Memento pattern using too much space, at one time running into "heap is full" messages. However, we were able to solve those issues with refactoring and debugging, and retain our belief that the Memento pattern works best. In addition, we don't use the Composite pattern to group and ungroup notes into gestures. This may decrease the simplicity and elegance of the program in some areas, but I maintain that there's more extensibility in straying from inheritance; the gestures might be less easy to manipulate, but they can be manipulated in more ways this way ('filtering' notes within a gesture, perhaps).

As always, with more time and knowledge, more refactoring could be done.

>Include an estimate of your velocity. How many story points did you estimate you would complete during this project? How many did you actually complete, how many person-hours did the team spend, and what is the ratio of points/person-hour?

We estimated that we would complete 22 story points, and actually ended up completed about 23 (still working at getting better at estimation). We spent about 27.5+ hours on this project, so around 6.875 hours per person, and that means that the rate of points/person-hour was about 0.83636364. In this project our velocity speeded up, mainly because we assigned the features we want to implement individually ahead of time and every one understood what their jobs were. And these features do not interfere each other so there's no overlapping in code we need to refactor later. This clearly showed that depending on the nature of the work, the rate would certainly vary as well.

>Include a short summary of your team retrospective. What went well that your team will keep doing during the next project assignment? What will you improve? How?

This did feel like a shorter assignment, which we appreciated (although unbeknownst to us, we'd completed part of it for our Project 8 stretch goals). Unfortunately, we didn't have a chance to meet until later in the week again, but we used our time productively and communicated well throughout. Everyone participated strongly, and contributed good ideas. We'll continue communicating well and being as proactive as possible. Hopefully we can improve our creative skills and bounce more ideas off one another in Project 9.

Sincerely yours,

Kaylin, Zach, Jing, and Tyler

